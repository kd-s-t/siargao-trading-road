name: CI/CD Build and Deploy to EC2

on:
  push:
    branches: [main]
  workflow_dispatch: # Manual trigger

jobs:
  build:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        run: |
          docker buildx create --use || true

      - name: Build frontend image
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
          NEXT_PUBLIC_API_URL: https://siargaotradingroad.com/api
          NEXT_PUBLIC_ENVIRONMENT: production
        run: |
          echo "üê≥ Building Next.js frontend image..."
          docker buildx build --platform linux/amd64 \
            --build-arg NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL \
            --build-arg NEXT_PUBLIC_ENVIRONMENT=$NEXT_PUBLIC_ENVIRONMENT \
            -t $ECR_REPOSITORY-frontend:$IMAGE_TAG \
            -t $ECR_REPOSITORY-frontend:latest \
            --load \
            -f Dockerfile \
            .
          echo "‚úÖ Frontend image built: $ECR_REPOSITORY-frontend:$IMAGE_TAG"

      - name: Build API image
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üê≥ Building Go API image..."
          docker buildx build --platform linux/amd64 \
            -t $ECR_REPOSITORY-api:$IMAGE_TAG \
            -t $ECR_REPOSITORY-api:latest \
            --load \
            -f golang.Dockerfile \
            .
          echo "‚úÖ API image built: $ECR_REPOSITORY-api:$IMAGE_TAG"

      - name: Save frontend image
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üíæ Saving frontend image..."
          docker save $ECR_REPOSITORY-frontend:$IMAGE_TAG -o frontend-image.tar
          docker save $ECR_REPOSITORY-frontend:latest -o frontend-image-latest.tar
          echo "‚úÖ Frontend image saved"

      - name: Save API image
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üíæ Saving API image..."
          docker save $ECR_REPOSITORY-api:$IMAGE_TAG -o api-image.tar
          docker save $ECR_REPOSITORY-api:latest -o api-image-latest.tar
          echo "‚úÖ API image saved"

      - name: Upload frontend image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-image
          path: |
            frontend-image.tar
            frontend-image-latest.tar
          retention-days: 1

      - name: Upload API image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-image
          path: |
            api-image.tar
            api-image-latest.tar
          retention-days: 1

  push-ecr:
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories if they don't exist
        run: |
          for REPO_NAME in "siargaotradingroad-production-frontend" "siargaotradingroad-production-api"; do
            echo "üîç Checking if ECR repository $REPO_NAME exists..."
            
            if ! aws ecr describe-repositories --repository-names $REPO_NAME --region us-east-1 2>/dev/null; then
              echo "üì¶ Creating ECR repository $REPO_NAME..."
              aws ecr create-repository \
                --repository-name $REPO_NAME \
                --region us-east-1 \
                --image-scanning-configuration scanOnPush=true \
                --image-tag-mutability MUTABLE
              echo "‚úÖ ECR repository $REPO_NAME created successfully"
            else
              echo "‚úÖ ECR repository $REPO_NAME already exists"
            fi
          done

      - name: Download frontend image artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-image

      - name: Download API image artifacts
        uses: actions/download-artifact@v4
        with:
          name: api-image

      - name: Load frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üì• Loading frontend image..."
          docker load -i frontend-image.tar
          docker load -i frontend-image-latest.tar
          docker tag $ECR_REPOSITORY-frontend:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY-frontend:$IMAGE_TAG
          docker tag $ECR_REPOSITORY-frontend:latest $ECR_REGISTRY/$ECR_REPOSITORY-frontend:latest
          echo "‚úÖ Frontend image loaded and tagged"

      - name: Load API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üì• Loading API image..."
          docker load -i api-image.tar
          docker load -i api-image-latest.tar
          docker tag $ECR_REPOSITORY-api:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY-api:$IMAGE_TAG
          docker tag $ECR_REPOSITORY-api:latest $ECR_REGISTRY/$ECR_REPOSITORY-api:latest
          echo "‚úÖ API image loaded and tagged"

      - name: Push frontend image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üì§ Pushing frontend image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY-frontend:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY-frontend:latest
          echo "‚úÖ Frontend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY-frontend:$IMAGE_TAG"

      - name: Push API image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üì§ Pushing API image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY-api:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY-api:latest
          echo "‚úÖ API image pushed: $ECR_REGISTRY/$ECR_REPOSITORY-api:$IMAGE_TAG"

      - name: Verify frontend image in ECR
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üîç Verifying frontend image in ECR..."
          if aws ecr describe-images --repository-name $ECR_REPOSITORY-frontend --image-ids imageTag=$IMAGE_TAG --region us-east-1; then
            echo "‚úÖ Frontend image verified in ECR"
          else
            echo "‚ùå Frontend image not found in ECR"
            exit 1
          fi

      - name: Verify API image in ECR
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üîç Verifying API image in ECR..."
          if aws ecr describe-images --repository-name $ECR_REPOSITORY-api --image-ids imageTag=$IMAGE_TAG --region us-east-1; then
            echo "‚úÖ API image verified in ECR"
          else
            echo "‚ùå API image not found in ECR"
            exit 1
          fi

  cleanup-ecr:
    runs-on: ubuntu-latest
    needs: [push-ecr]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Clean up old ECR images
        env:
          ECR_REPOSITORY: siargaotradingroad-production
          KEEP_IMAGES: 5
        run: |
          echo "üßπ Cleaning up old ECR images..."
          
          for REPO in "frontend" "api"; do
            REPO_NAME="${ECR_REPOSITORY}-${REPO}"
            echo "üì¶ Processing repository: $REPO_NAME"
            
            IMAGE_COUNT=$(aws ecr describe-images \
              --repository-name $REPO_NAME \
              --region us-east-1 \
              --query 'length(imageDetails)' \
              --output text 2>/dev/null || echo "0")
            
            echo "üìä Found $IMAGE_COUNT images in $REPO_NAME"
            
            if [ "$IMAGE_COUNT" -gt "$KEEP_IMAGES" ]; then
              IMAGES_TO_DELETE=$((IMAGE_COUNT - KEEP_IMAGES))
              echo "üóëÔ∏è Deleting $IMAGES_TO_DELETE old images from $REPO_NAME..."
              
              aws ecr list-images \
                --repository-name $REPO_NAME \
                --region us-east-1 \
                --filter "tagStatus=TAGGED" \
                --query "sort_by(imageIds[?imageTag!='latest'],&imageTag)[:-$KEEP_IMAGES].imageTag" \
                --output text | \
              tr '\t' '\n' | \
              while read tag; do
                if [ ! -z "$tag" ] && [ "$tag" != "latest" ]; then
                  echo "  Deleting image tag: $tag"
                  aws ecr batch-delete-image \
                    --repository-name $REPO_NAME \
                    --region us-east-1 \
                    --image-ids imageTag=$tag || true
                fi
              done
              
              echo "‚úÖ Cleaned up old images from $REPO_NAME"
            else
              echo "‚úÖ No cleanup needed for $REPO_NAME (only $IMAGE_COUNT images, keeping $KEEP_IMAGES)"
            fi
          done
          
          echo "‚úÖ ECR cleanup complete"

  deploy:
    needs: [push-ecr]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Install network tools
        run: |
          sudo apt-get update
          sudo apt-get install -y netcat-openbsd

      - name: Add EC2 to known hosts
        run: |
          EC2_HOST="3.237.15.10"
          EC2_PORT="${EC2_PORT:-22}"
          
          echo "üîç Adding EC2 host to known_hosts..."
          ssh-keyscan -p $EC2_PORT -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || {
            echo "‚ö†Ô∏è ssh-keyscan failed, trying alternative method..."
            # Try connecting once to add host key
            ssh -o StrictHostKeyChecking=accept-new -p $EC2_PORT ${{ secrets.EC2_USER }}@$EC2_HOST "echo 'SSH connection test'" || {
              echo "‚ùå SSH connection failed"
              exit 1
            }
          }
          
          echo "‚úÖ Host added to known_hosts successfully"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install Docker and AWS CLI on EC2
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            echo "üîß Checking and installing required tools..."
            
            wait_for_apt() {
              echo "‚è≥ Waiting for apt to be available..."
              local max_attempts=30
              local attempt=0
              
              while [ $attempt -lt $max_attempts ]; do
                if sudo lsof /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
                  echo "‚è≥ Apt lock exists, waiting... (attempt $((attempt+1))/$max_attempts)"
                  sleep 2
                  attempt=$((attempt+1))
                else
                  echo "‚úÖ Apt is available"
                  return 0
                fi
              done
              
              echo "‚ö†Ô∏è Apt lock still exists after waiting, attempting to clear..."
              sudo pkill -9 apt-get || true
              sudo pkill -9 apt || true
              sudo pkill -9 dpkg || true
              sleep 2
              sudo rm -f /var/lib/dpkg/lock-frontend
              sudo rm -f /var/lib/dpkg/lock
              sudo rm -f /var/cache/apt/archives/lock
              sudo dpkg --configure -a || true
              echo "‚úÖ Locks cleared"
            }
            
            disable_auto_updates() {
              echo "üîß Disabling automatic updates temporarily..."
              sudo systemctl stop unattended-upgrades || true
              sudo systemctl disable unattended-upgrades || true
            }
            
            wait_for_apt
            disable_auto_updates
            
            # Check and install Docker
            if ! command -v docker &> /dev/null; then
              echo "üì¶ Installing Docker..."
              wait_for_apt
              sudo apt-get update
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo mkdir -p /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              wait_for_apt
              sudo apt-get update
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo usermod -aG docker $USER
              echo "‚úÖ Docker installed"
            else
              echo "‚úÖ Docker already installed"
            fi
            
            # Check and install AWS CLI
            if ! command -v aws &> /dev/null; then
              echo "üì¶ Installing AWS CLI..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
              echo "‚úÖ AWS CLI installed"
            else
              echo "‚úÖ AWS CLI already installed"
            fi
            
            # Verify installations
            docker --version
            aws --version
            echo "‚úÖ All tools verified"
          EOF

      - name: Setup project directory and repository
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            newgrp docker 2>/dev/null || true
            
            echo "üìÅ Setting up project directory..."
            mkdir -p ~/siargao-trading-road
            cd ~/siargao-trading-road
            
            if [ ! -d ".git" ]; then
              echo "üì• Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            else
              echo "üì• Pulling latest changes..."
              git pull origin main
            fi
            echo "‚úÖ Repository ready"
          EOF

      - name: Load environment from SSM
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            echo "üîë Loading environment from SSM Parameter Store..."
            SSM_PATH="/siargaotradingroad/production"
            AWS_REGION="us-east-1"
            aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text | awk -F '\t' '{split($1,a,"/"); print a[length(a)] "=" $2}' > .env || echo "# No SSM parameters found" > .env
            echo "‚úÖ .env created from SSM at $SSM_PATH"
          EOF

      - name: Login to ECR on EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << EOF
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            echo "üîê Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin "\${ECR_REGISTRY}"
            echo "‚úÖ Logged into ECR"
          EOF

      - name: Verify images exist in ECR
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << EOF
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            
            echo "üîç Verifying images exist in ECR..."
            if ! aws ecr describe-images --repository-name siargaotradingroad-production-frontend --image-ids imageTag=$IMAGE_TAG --region us-east-1 2>/dev/null; then
              echo "‚ùå Frontend image does not exist in ECR!"
              exit 1
            fi
            
            if ! aws ecr describe-images --repository-name siargaotradingroad-production-api --image-ids imageTag=$IMAGE_TAG --region us-east-1 2>/dev/null; then
              echo "‚ùå API image does not exist in ECR!"
              exit 1
            fi
            echo "‚úÖ Both images verified in ECR"
          EOF


      - name: Pull Docker images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << EOF
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            IMAGE_TAG="${{ github.sha }}"
            FRONTEND_IMAGE="\${ECR_REGISTRY}/siargaotradingroad-production-frontend:\${IMAGE_TAG}"
            API_IMAGE="\${ECR_REGISTRY}/siargaotradingroad-production-api:\${IMAGE_TAG}"
            
            echo "üê≥ Pulling frontend image..."
            docker pull "\${FRONTEND_IMAGE}"
            echo "üê≥ Pulling API image..."
            docker pull "\${API_IMAGE}"
            echo "‚úÖ Images pulled successfully"
          EOF

      - name: Update docker-compose.yml
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << EOF
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            IMAGE_TAG="${{ github.sha }}"
            FRONTEND_IMAGE="\${ECR_REGISTRY}/siargaotradingroad-production-frontend:\${IMAGE_TAG}"
            API_IMAGE="\${ECR_REGISTRY}/siargaotradingroad-production-api:\${IMAGE_TAG}"
            
            echo "üìù Updating docker-compose.yml with image tags..."
            printf 'version: '\''3.8'\''\n\nservices:\n  api:\n    image: %s\n    container_name: siargao-api\n    ports:\n      - "3020:3020"\n    env_file:\n      - .env\n    environment:\n      - PORT=3020\n      - GIN_MODE=release\n    restart: unless-stopped\n    networks:\n      - siargao-network\n\n  frontend:\n    image: %s\n    container_name: siargao-frontend\n    ports:\n      - "3021:3021"\n    env_file:\n      - .env\n    environment:\n      - PORT=3021\n      - NODE_ENV=production\n    depends_on:\n      - api\n    restart: unless-stopped\n    networks:\n      - siargao-network\n\nnetworks:\n  siargao-network:\n    driver: bridge\n' "\${API_IMAGE}" "\${FRONTEND_IMAGE}" > docker-compose.yml
            echo "‚úÖ docker-compose.yml updated"
          EOF

      - name: Stop existing containers
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            echo "üõë Ensuring containers are stopped..."
            docker compose down || true
            echo "‚úÖ Containers stopped"
          EOF

      - name: Run database migrations
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << EOF
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            IMAGE_TAG="${{ github.sha }}"
            API_IMAGE="\${ECR_REGISTRY}/siargaotradingroad-development-api:\${IMAGE_TAG}"
            
            echo "üîÑ Running database migrations..."
            docker run --rm --env-file .env \${API_IMAGE} /app/siargao-trading-road migrate || {
              echo "‚ö†Ô∏è Migration command not found, migrations will run on container start"
            }
            echo "‚úÖ Migrations completed"
          EOF

      - name: Start containers
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            echo "üöÄ Starting containers with docker-compose..."
            docker compose up -d
            echo "‚úÖ Containers started"
          EOF

      - name: Verify deployment
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            echo "üìä Container status:"
            docker compose ps
            echo "‚úÖ Deployment complete!"
          EOF

  cleanup-ec2:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Add EC2 to known hosts
        run: |
          EC2_HOST="3.237.15.10"
          EC2_PORT="${EC2_PORT:-22}"
          
          echo "üîç Adding EC2 host to known_hosts..."
          ssh-keyscan -p $EC2_PORT -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || {
            echo "‚ö†Ô∏è ssh-keyscan failed, trying alternative method..."
            ssh -o StrictHostKeyChecking=accept-new -p $EC2_PORT ${{ secrets.EC2_USER }}@$EC2_HOST "echo 'SSH connection test'" || {
              echo "‚ùå SSH connection failed"
              exit 1
            }
          }
          
          echo "‚úÖ Host added to known_hosts successfully"

      - name: Clean up Docker resources on EC2
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@3.237.15.10 << 'EOF'
            set -e
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            cd ~/siargao-trading-road
            
            echo "üßπ Cleaning up Docker resources..."
            
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1
            
            echo "üóëÔ∏è Removing old images (keeping latest 2)..."
            docker images --format "{{.Repository}}:{{.Tag}}" | grep siargaotradingroad-production | sort -V | head -n -2 | xargs -r docker rmi -f || true
            
            echo "üßπ Pruning unused Docker resources (excluding running containers)..."
            docker system prune -a -f || true
            
            echo "üìã Cleaning up old logs..."
            sudo journalctl --vacuum-time=3d || true
            sudo find /var/log -type f -name "*.log" -mtime +7 -delete || true
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1
            
            echo "üîÑ Ensuring containers are running..."
            docker compose up -d || true
            
            echo "üìä Container status after cleanup:"
            docker compose ps
            
            echo "‚úÖ Cleanup complete"
          EOF

